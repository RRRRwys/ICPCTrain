**2021-01-01**

- CF1466G，2，2500，T，T，"定义f(n,w)表示sn中w出现的次数，g(n,w)为在sn中经过ti字符的w的数目，f(n,w)=2*f(n-1,w)+g(n,w)=2^{n-k}*f(k,w)+\sum_{j=k+1}^n 2^{n-j}*g(j,w)，选取 k 使得|sk| > w；对于这种情况，ti == tj 时，有g(i,w)==g(j,w)；第一部分kmp统计f，第二部分对每一种字母kmp统计g的贡献，注意边界" -- wys
- AGC051A，2，500，T，T，"构造可以发现最外层形式固定，接下的一层的是由两种长度的边d,d-1交替构成的12边形，令方案数为f(d,d-1)。可以发现只有两种构造方式，有f(n,m)=f(n-1,m)+f(n,m-1), 然后根据组合数递推式C(n,m) = C(n-1,m) + C(n-1,m-1)，可发现f(n,m) = C(n+m,m) = C(n+m-1,m) + C(n+m-1,m-1) = f(n-1,m) + f(n,m-1)，于是发现f(n,m)与C(n+m,m)差了1/2，这个组合数的形式需要记忆" -- wys
- cf342E，1，2400，T，T，“对询问分块，块内的修改暴力处理，每个块结束时将当前块修改作用到树上” -- zyp
- cf375D，1，2400，T，T，“dfs序+莫队” -- zyp
- cf449D，1，2400，T，T，“通过dp得到某个数所有超集的数目 然后代公式即可” -- zyp
- AGC001B，1，500，T，T，"第一次反射构成一个大平行四边形，之后的所有操作都可以递归的化成：平行四边形一个钝角发射光线" -- wys
- AGC001C，1，600，T，T，“枚举答案中树直径的中边，讨论即可” -- zyp

--- 

**2021-01-25**

- cf865d，1，2400，T，T，贪心 把买卖的式子转换一下就可以用优先队列贪了 -- zyp
- cf446c，1，2400，in queue，F，搞出模意义下的斐波那契数列的通项公式 然后线段树加加减减打打标记 --zyp
- cf1187d，1，2400，T，F，将sort转换为swap 然后只要验证下一个可能位置前所有值都大于当前值即可 对每个位置操作完就更新一下 -- zyp
- AGC001D, 3, 1000, T, T, “将回文串中相等字符想象成有边相连，目标就是使得整个图联通，发现回文串的奇偶性会影响结果，分析发现奇数长度的串，只能作为开头和结尾，偶数长度可以随便放，因此奇数长度大于2一定无解；将奇+偶，偶+奇，偶+偶，奇+奇，分别构造出可行的方案，把他们串起来即可” -- wys
- cf145e，1，2400，T，F，线段树同时处理翻转前和翻转后的结果即可 -- zyp
- AGC002C，1，500，T，F，“考虑最后一步从哪里切开，两边的可以朝这个位置按顺序切” -- wys
- cf1358e，1，2400，T，F，先证（猜）一下答案肯定大于n/2 然后观察k相同时相邻两个区间的和的差 发现是一个前缀和 再观察k+1时候的结果 发现就差一个x 然后枚举一下k就行了 -- zyp
- AGC002D，3，1000，T，T，“可持久化并查集按编号从小到大加边，二分答案，内存开到上限” -- wys
- cf484d，1，2400，T，F，先按照递增递减分段 然后再枚举各种情况dp即可 -- zyp
- cf1114F，1cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可，2400，T，F，一棵线段树处理区间乘法 另一棵线段树处理一下区间出现的素数 然后套欧拉函数公式即可 -- zyp
- AGC003C，1，600，T，F，“离散化之后的编号与位置编号，奇+偶数目与偶+奇数目取max” -- wys
- cf1469f，1，2600， T，F，贪心，选择剩余最长链的中心挂在树上距离跟最近的白色点上即可。 -- lsz
- cf1467e，1,2500，T，F，由每个点的修改次数最多为size+1，故直接dfs的时候搞一搞就好 -- lsz
- AGC003D，3，1100，T，T，“素因子分解后，每个素因子的指数模3得到序列a，考虑对于每个处理后非1的数，必定有唯一一个与他对应的数，因此将可能的乘积为立方数的对，一定是一一对应的；因此，建图之后1是一个单点，其余的每一个联通块大小都不超过2；讨论每种情况，容易求出最大独立集。数据范围为1e10，时限很紧，分解质因数采用杜教的，小的预处理，大的rho” -- wys
- cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可 -- zyp
- cf1036f，1，2400，T，F，枚举gcd 用莫比乌斯函数容斥即可 开根的时候要注意精度问题 -- zyp
- AGC004C，1，700，T，T，“构造题，搞左右两个交错互补的叉子，分别与交的的网格求并即可” -- wys
- AGC004D，2，800，T，T，“容易知道1一定指向自己，因此题目就是求切最少的边使得，每棵树深度不超过K-1，根所在树不超过K；因此按深度倒序的考虑，每个未删除的点选择它的K-1级祖先与K级祖先之间的边” -- wys
- cf986c，1，2500，T，F，引入辅助结点 将条件转换为结点连向辅助结点的边 然后跑dfs即可 要注意的是存图会导致内存不够 所以边要现场算 -- zyp 
- cf1305f，1，2500，T，F，考虑到操作总数不超过n 至少有n/2的数字操作数不超过1 所以随机这个数 把它、+1、-1的数的因子搞出来算一遍 然后取最小值 -- zyp
- AGC005C，1，700，T，F，“对于一棵树，最大的2个值一定相等，并且是直径的长度，这样就可以把整个链推出来，其余的点按值从小到大加入树中，如果树中存在一个点的值恰好比当前值小1，则可以把这个点连上去” -- wys
- AGC005D，2，900，T，T，“容斥，枚举匹配中包含的非法匹配个数，问题转化为求解非法的二分图上的匹配数位恰好为k的方案数，可以发现这个二分图由一些独立的链构成，因此可以求解每一条链的方案，之后再卷积合并答案；对于一条链的二分图匹配方案数，转化为2染色，相邻两边不能同色的方案数，n^2 dp 即可” -- wys
- cf551e，1，2500，T，F，分块 对于修改 块内直接加 整个块打标记 对于查询 块内排序 用二分查询是否存在 找出最大最小index然后相减即可 -- zyp
- cf580e，1，2500，T，F，查询区间l r是否存在长度为d的循环节可以转换为l~(r-x)与(l+x)~r是否相同 然后判断字符串相同用哈希 区间修改和哈希的计算用线段树整一下 -- zyp
- cf449C，1，2500，T，F，贪心 从大到小枚举素数 将素数倍数中未使用的数放入vector 如果vector大小为偶数 则两两配对使用 否则移除2*x后两两配对 -- zyp
- cf468C，1，2500，T，F，设x<1e18 [1+x,1e18+x]结果是[1,1e18]+x 因此只要算出[1,1e18]的结果 然后区间右移a-x即可 -- zyp
- cf594d，1，2500，T，F，询问按右端点排序 维护一个树状数组表示区间中出现的素数的乘积 然后按照欧拉函数的公式算答案就行了 -- zyp

---

**2021-02-01**

- cf1065f，1，2500，T，F， 先算可以任意回到根节点的叶子节点的数目 然后再dp算不能回到根节点的路径的答案即可 -- zyp
- cf1017f，1，2500，T，F，此题主要问题是空间太小 所以需要用埃式筛并且埃式筛数组只开x%6=+-1的情况 其他的就正常推公式即可 -- zyp
- cf1461f，2,2700，T，F，ai乘积大于2n时全乘号链接，ai乘积小于2n时dp转移即可 -- lsz
- cf1452g，2，2700，T，F，将原问题转化为每一个点至少可以进行的回合数，即多少个回合内不会有任何一个chip到这个点，然后再将相邻的点向外扩展最终覆盖整棵树即可 -- lsz
- cf455d，2，2700，T，F，分块，模拟移动时需要用deque而不是list来减少时间 -- zyp
- cf1270g，2，2700，T，F，i->i-a[i]连边 然后找一个环即可 -- zyp
- cf1442d，2，2800，T，F，dp决策单调性分治 -- lsz
- cf1422e，2，2700，T，F，分类讨论dp一下 -- lsz
- cf1422f，2，2800，T，F，区间lcm，值域2e5，根据值域的开根，小于开根的暴力线段树，大于开根的主席树 -- lsz
- cf351d，2，2700，T，F，莫队 一个map记录间隔 一个deque记录出现的位置 -- zyp
- cf1461f，2，2700，T，F，先分类讨论 主要处理+*的情况 按照0分割数组 每个子数组里进行dp即可 -- zyp
- AGC006C，2，800，T，T，“每次跳跃的位置的期望由位置的期望可表示为：两边之和减去中间，在差分序列上就是交换2个相邻元素，K次就快速幂算排列” -- wys
- AGC008C，1，600，T，T，“有用的只有3个，讨论奇偶，是否为0，注意细节” -- wys
- AGC008D，2，800，T，F，“左右分开贪心，每种数字按照确定位置为优先级” -- wys
- AGC009B，2，800，T，F，“dfs(u)表示以u胜利的最少场次，转移时将最深的深度贪心的放在靠上的位置即可” -- wys
- cf906d，2，2700，T，F，扩展欧拉定理 因为要分是否大于欧拉函数 所以要魔改一下快速幂 返回的范围改为 0~2*p-1 -- zyp
- AGC010B，1，500，T，T，“考虑相邻2个人数的差值即可，细节调了一年” -- wys
- cf713d，2，2700，T，F，dp[i][j]表示以ij为右下角最大正方形边长 在dp上建立二维st表 询问的时候二分答案即可
- AGC009C，3，1100，T，T，“dpx[i][j]表示"前i个数，划分为2个集合X,Y，第i个属于集合X，最后一个加入集合Y中的数字编号为j"的方案数。dpy相似，考虑dp的转移过程，只保留dp的第二维，用线段树更新dp数组” -- wys
- AGC010C，1，700，T，F，“仔细读题。把点上权转化到边上” -- wys
- cf908G，2，2800，T，F，dp[i][j][k]表示当前在第i位 数字是j 大于等于j的数共有k个 然后来一波数位dp 然后再枚举数字和大于等于该数字的个数 求和即可 -- zyp

---

**2021-02-08**

- cf995E，2，2700，T，F，从begin和end各随机走出1e5条长100的路径 然后判断是否有相遇的 -- zyp
- cf1182F，2，2700，T，F，题意翻译一下就是找到模q后离q/2最近的数 然后就把每个数分成大于sqrt(b-a+1)和小于两块 然后两块组合、二分一下就行了 主要问题是不能用map 这题有点卡常 -- zyp
- AGC007C，3，1000，F，T，“没代码量不写了，不考虑间距的变化，每次操作完，重新编号后问题形式不变；然后难点在于发现一个等差的间隔序列，在一次操作后每个间距的期望仍然是等差数列，找出首项和公差的递推式，每一步的贡献的式子比较容易求出来” -- wys
- cf1344d，2，2700，T，F，对每个i算一下bi增加一整个式子增加的值 然后二分这个值 保证bi的和大于等于k即可 -- zyp
- cf575A，2，2700，T，F，对每一个修改的数将它周围单独算 然后两个修改数之间的范围分成三段 xxx-模为1 一串模为1 模为1-xxx 然后分别来快速幂和线段树 把矩阵搞出来 然后算算就行了 全是细节问题 -- zyp
- AGC010D，3，1000，F，T，“博弈，题意是一组数字，每次选择一个大于1的数减一，然后除以所有数的GCD。首先，当所有数字都是奇数时，先手操作后会出现一个偶数，由于存在奇数和偶数因此去掉GCD后奇偶性不变，后手就可以继续把这个数变成奇数，最终到达全1状态，无法继续操作，先手必败；当包含奇数个偶数时，原先数组保证GCD为1，因此至少有一个奇数，先手每次将一个偶数变为奇数，GCD不影响奇偶性，后手不管如何操作，一定会变成原本的状态，最终，后手一定会遇到全是奇数的状态，因此先手必胜；如果有偶数个偶数，2个即以上的奇数，不管怎么选择，状态总会转移为必胜态，因此必败；最后一种情况就是包含偶数个偶数，1个奇数，这种情况如果选择偶数一定会转移到必胜态，因此只能选择这个奇数，于是我们直接暴力的模拟操作的过程，直到转移至其他情况为止”
- cf794F，2，2800，T，F，对每个数出现的位置建立线段树 打标记就打某个数变成了哪个数 然后正常线段树操作就行了 -- zyp
- cf633G，2，2800，T，F，先来一波dfs序 然后建一棵线段树 线段树每个节点用bitset表示这个数是否出现 然后加法操作变成循环左移 正常线段树操作就行了 -- zyp
- cf1303f，2，2800，T，F，因为c只会增加 所以对每种颜色分别考虑它的变化 正着来一次 反着来一次 记录一下相对于前一个改变此颜色的操作 对当前位置答案造成的影响 然后累加一下就行了 -- zyp
- AGC011C，2，800， F，T，“考虑题目的增强版，如果新图C中点(a,b)与点(a',b')有边相连，iff a与a'在图A有边且b与b'在图B有边，求C的连通块数目。先考虑2个图都是联通的：|A|=1时，答案是|B|；如果2个图点数均大于等于2，可以发现只有当存在一条从a到a’的路径，b与b'的路径，他们长度相等时(a,b)与(a',b')联通，进一步分析发现通过重走一条边可使得一条路径长度每次加2，因此只用考虑奇偶性；发现如果一个图中存在奇环时，可以通过这个奇环控制路径的奇偶性，因此当A,B中有一个包含奇环时，一定形成1联通块；否则AB就都是二分图，可以发现二分图会形成2个连通块。接下来，考虑每一对联通块计算答案；令总点数为N，单点的数目为I，二分图联通块数目为P，含奇环数目为Q：首先考虑单点与单点对，为$I_A * I_B$；单点与其他点 $I_A * (N_B-I_B) + (N_A-I_A) * I_B$；含奇环图之间为，$Q_A * Q_B$；含奇环与二分图，$Q_A * P_B+P_A * Q_B$；二分图之间，$2 * PA * PB$，求和即可” -- wys
- AGC012B，1，700，F，F，“直接操作倒序添加，已经染过色就不用操作了” -- wys
- cf1369f，2，2700，T，F，先手是否可以决定自己赢或输可以通过dp算出来 然后对每一轮依次计算 如果某一轮时此人可以决定自己赢或输 或无法决定自己赢或输 就结束 否则就当它此轮是先手时用dp的结果 否则用dp反向的结果 -- zyp
- AGC012C，3，1000，T，F，“构造题，|s|范围要求很严。一个思路是将2个排列拼起来，后面的顺序放置，考虑前面数字顺序的影响，答案就可以转化为前面排列包含n个递增序列的构造，可以发现从小到大加数字，大的数字放在末尾答案*2+1，放在开头答案+1，dfs出方案即可” -- wys
- AGC012D，3，1000，F，T，“首先，发现a b可交换，a c可交换时，b c可交换，因此只需要对可交换的球连边，对于每个联通块统计答案即可，类似字符串排列计数；对于操作1，可以对于每个元素贪心的选择对应颜色最小的权重的连边；对于操作2，可以选取最小的权重最小和次小的球，每个球从这2个中选择，不同色的权重最小的球即可” -- wys
- AGC013B，1，500，T，F，“随便选个点dfs出一条尽量深的路，再挑一个与所选点相邻的未被经过的点，再dfs一遍即可” -- wys

---

**2021-02-15**

- cf1148f，2，2700，T，F， 贪心 枚举每一位 将所有最高位是这一位的数现有的值相加 如果大于零就将答案这一位设置为1 然后更新所有数 -- zyp
- cf452f，2，2700，T，F，猜一下NO的情况很少 所以每个位置暴力搜一下周围100位置 然后判断是否有合法情况即可 -- zyp
- cf364D，2，2900，T，F，从序列里随机选一个数 把它的因数都搞出来 然后枚举序列 把他们和这个数的gcd计数一下 然后得到每个因数倍数的数目 最后把所有数目大于等于n/2的数取个最大值 多来几次这个随机操作取最大值就可以了 -- zyp
- cf585E，2，2900，T，F，枚举gcd 算出gcd是此数的集合的大小 然后乘以因子不包括此数的数的数目 容斥一下就行了 -- zyp
- AGC011D，2，900，T，T，“首先按照每一轮操做可以看作每次添加一个字母，如果是A它前面的那个字符一定需要改成B，如果是B，它本身会变成A，因此可以发现几个性质：末尾一定是A、最终会变成BABAB的形式；继续实验发现当首位是B时整个操作就是整体取反之后循环左移，首位是A就将这个字母取反；因此就要考虑经过多少次操作可以进入BABABA的状态，可以递推出来，长度为奇数的情况更复杂一些，细节调了一年” -- wys
- cf1285F，2，2900，T，F，枚举gcd 对每个gcd 搞一个栈 从大到小枚举它的倍数 如果存在 就用容斥判断栈里是否有和它互质的数 有就不断出栈知道不存在互质的数 求一下答案 然后把这个数压栈 最后所有答案求个最大值就行了 -- zyp
- cf1198F，2，2900，T，F，随机搞一波 第一第二个分别放进第一第二组 然后向后遍历 如果模1组gcd是0 就放进2组 否则放进1组 然后看最后两组gcd是否是1 是1就搞定了 否则继续搞 -- zyp
- AGC013C，1，700，T，T，“先发现最终的位置很容易求出，并且如果问题在一个数轴上就很容易解决，因为相对位置不变，单本题在环上，因此要考虑0号蚂蚁当前的编号；重新看这个问题，可以发现每当有一只蚂蚁经过0点，就会影响整体蚂蚁的编号，继续考虑逆时针、顺时针的影响即可，边界需要仔细处理，T有可能很大要注意取模。第二个性质有点儿难想到” -- wys
- AGC014B，1，500，T，F，“实验几次，可以发现只有每个点出现偶数次时，才能构造出解” -- wys
- cf338D，2，2900，T，F，i等于所有数的lcm 然后j用模数不互质的中国剩余定理算一下 然后用ij验证一下是否符合条件即可 -- zyp
- AGC012E，3，1000，T，T，“可以处理出每个可能的V、V/2....对应的区间，问题转化为每种区间选择一个，把整个区间覆盖，每个位置是否可以属于V，dpL[S]表示使用S这个状态最多覆盖的前缀，后缀同理处理dpR[S]，对于每个V划分的区间，前缀后缀能否与当前区间组合出一个覆盖” -- wys
- cf878D，2，2900，T，F，因为只有12个怪兽 所以可以状态压缩表示此怪兽有可能从那几个怪兽演化过来 然后把取最大值操作把状态转化为或操作 最小值转化为与操作 然后询问 因为每一个位置最多12种个值 所以先排个序 贪心的看是否有可能从这个怪兽变化过来 输出一下就行了 （其实爆搜也能过） -- zyp
- AGC013D，2，900，T，T，“首先需要想到 dp[i][j] 表示前i个操作后，桶里剩下j个红球的序列数目，容易发现直接这样dp会将一些序列重复计数；为了看出重复的序列是什么，我们以操作为横轴，桶中的红球数目作为纵轴，画出所有可能的转移情况，可以发现，当图中2个路径形状一致时，会重复计数，并且如果将所有的路径向下平移，就可以将所有的路径去重，因此，我们只需要统计所有红球数目曾经到达过0的方案即可；一个思路就是在dp中加入一维表示dp[i][j]中的j是否曾经到达过0；另一个想法，我们将一组重复统计的路径画出来，可以发现，他们水平的间距为1，均匀分布，也就是说，当桶的容量变为n-1时，所有可以到达n个红球的情况都被去除了，因此将二者做一下差分即可，dp转移的细节容易实现” -- wys
- AGC014C，1，700，T，F，“发现每次都是先走K步，再解K个锁，因此除了第一步，之后每一步都相当于没有障碍，于是对于所有第一步能到达的点取最小值即可” -- wys
- AGC014D，2，900，T，T，“博弈题，自己手玩几组数据发现，先手要想取得主动一定是从叶子的父亲开始，另一个角度来看一个策略就是每次找到当前没染色的最深的节点x，他父亲节点y，如果有1个以上的儿子那么显然先手必胜了，否则就只能将y和x删掉；重复这个过程，剩一个点则先手赢，否则后手赢” -- wys