**2021-01-01**

- CF1466G，2，2500，T，T，"定义f(n,w)表示sn中w出现的次数，g(n,w)为在sn中经过ti字符的w的数目，f(n,w)=2*f(n-1,w)+g(n,w)=2^{n-k}*f(k,w)+\sum_{j=k+1}^n 2^{n-j}*g(j,w)，选取 k 使得|sk| > w；对于这种情况，ti == tj 时，有g(i,w)==g(j,w)；第一部分kmp统计f，第二部分对每一种字母kmp统计g的贡献，注意边界" -- wys
- AGC051A，2，500，T，T，"构造可以发现最外层形式固定，接下的一层的是由两种长度的边d,d-1交替构成的12边形，令方案数为f(d,d-1)。可以发现只有两种构造方式，有f(n,m)=f(n-1,m)+f(n,m-1), 然后根据组合数递推式C(n,m) = C(n-1,m) + C(n-1,m-1)，可发现f(n,m) = C(n+m,m) = C(n+m-1,m) + C(n+m-1,m-1) = f(n-1,m) + f(n,m-1)，于是发现f(n,m)与C(n+m,m)差了1/2，这个组合数的形式需要记忆" -- wys
- cf342E，1，2400，T，T，“对询问分块，块内的修改暴力处理，每个块结束时将当前块修改作用到树上” -- zyp
- cf375D，1，2400，T，T，“dfs序+莫队” -- zyp
- cf449D，1，2400，T，T，“通过dp得到某个数所有超集的数目 然后代公式即可” -- zyp
- AGC001B，1， 500，T，T，"第一次反射构成一个大平行四边形，之后的所有操作都可以递归的化成：平行四边形一个钝角发射光线" -- wys
- AGC001C，1，600，T，T，“枚举答案中树直径的中边，讨论即可” -- zyp

--- 

**2021-01-25**

- cf865d，1，2400，T，T，贪心 把买卖的式子转换一下就可以用优先队列贪了 -- zyp
- cf446c，1，2400，in queue，F，搞出模意义下的斐波那契数列的通项公式 然后线段树加加减减打打标记 --zyp
- cf1187d，1，2400，T，F，将sort转换为swap 然后只要验证下一个可能位置前所有值都大于当前值即可 对每个位置操作完就更新一下 -- zyp
- AGC001D, 3, 1000, T, T, “将回文串中相等字符想象成有边相连，目标就是使得整个图联通，发现回文串的奇偶性会影响结果，分析发现奇数长度的串，只能作为开头和结尾，偶数长度可以随便放，因此奇数长度大于2一定无解；将奇+偶，偶+奇，偶+偶，奇+奇，分别构造出可行的方案，把他们串起来即可” -- wys
- cf145e，1，2400，T，F，线段树同时处理翻转前和翻转后的结果即可 -- zyp
- AGC002C，1，500，T，F，“考虑最后一步从哪里切开，两边的可以朝这个位置按顺序切” -- wys
- cf1358e，1，2400，T，F，先证（猜）一下答案肯定大于n/2 然后观察k相同时相邻两个区间的和的差 发现是一个前缀和 再观察k+1时候的结果 发现就差一个x 然后枚举一下k就行了 -- zyp
- AGC002D，3，1000，T，T，“可持久化并查集按编号从小到大加边，二分答案，内存开到上限” -- wys
- cf484d，1，2400，T，F，先按照递增递减分段 然后再枚举各种情况dp即可 -- zyp
- cf1114F，1cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可，2400，T，F，一棵线段树处理区间乘法 另一棵线段树处理一下区间出现的素数 然后套欧拉函数公式即可 -- zyp
- AGC003C，1，600，T，F，“离散化之后的编号与位置编号，奇+偶数目与偶+奇数目取max” -- wys
- cf1469f，1，2600， T，F，贪心，选择剩余最长链的中心挂在树上距离跟最近的白色点上即可。 -- lsz
- cf1467e，1,2500，T，F，由每个点的修改次数最多为size+1，故直接dfs的时候搞一搞就好 -- lsz
- AGC003D，3，1100，T，T，“素因子分解后，每个素因子的指数模3得到序列a，考虑对于每个处理后非1的数，必定有唯一一个与他对应的数，因此将可能的乘积为立方数的对，一定是一一对应的；因此，建图之后1是一个单点，其余的每一个联通块大小都不超过2；讨论每种情况，容易求出最大独立集。数据范围为1e10，时限很紧，分解质因数采用杜教的，小的预处理，大的rho” -- wys
- cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可 -- zyp
- cf1036f，1，2400，T，F，枚举gcd 用莫比乌斯函数容斥即可 开根的时候要注意精度问题 -- zyp
- AGC004C，1，700，T，T，“构造题，搞左右两个交错互补的叉子，分别与交的的网格求并即可” -- wys
- AGC004D，2，800，T，T，“容易知道1一定指向自己，因此题目就是求切最少的边使得，每棵树深度不超过K-1，根所在树不超过K；因此按深度倒序的考虑，每个未删除的点选择它的K-1级祖先与K级祖先之间的边” -- wys
- cf986c，1，2500，T，F，引入辅助结点 将条件转换为结点连向辅助结点的边 然后跑dfs即可 要注意的是存图会导致内存不够 所以边要现场算 -- zyp 
- cf1305f，1，2500，T，F，考虑到操作总数不超过n 至少有n/2的数字操作数不超过1 所以随机这个数 把它、+1、-1的数的因子搞出来算一遍 然后取最小值 -- zyp
- AGC005C，1，700，T，F，“对于一棵树，最大的2个值一定相等，并且是直径的长度，这样就可以把整个链推出来，其余的点按值从小到大加入树中，如果树中存在一个点的值恰好比当前值小1，则可以把这个点连上去” -- wys
- AGC005D，2，900，T，T，“容斥，枚举匹配中包含的非法匹配个数，问题转化为求解非法的二分图上的匹配数位恰好为k的方案数，可以发现这个二分图由一些独立的链构成，因此可以求解每一条链的方案，之后再卷积合并答案；对于一条链的二分图匹配方案数，转化为2染色，相邻两边不能同色的方案数，n^2 dp 即可” -- wys
- cf551e，1，2500，T，F，分块 对于修改 块内直接加 整个块打标记 对于查询 块内排序 用二分查询是否存在 找出最大最小index然后相减即可 -- zyp
- cf580e，1，2500，T，F，查询区间l r是否存在长度为d的循环节可以转换为l~(r-x)与(l+x)~r是否相同 然后判断字符串相同用哈希 区间修改和哈希的计算用线段树整一下 -- zyp
- cf449C，1，2500，T，F，贪心 从大到小枚举素数 将素数倍数中未使用的数放入vector 如果vector大小为偶数 则两两配对使用 否则移除2*x后两两配对 -- zyp
- cf468C，1，2500，T，F，设x<1e18 [1+x,1e18+x]结果是[1,1e18]+x 因此只要算出[1,1e18]的结果 然后区间右移a-x即可 -- zyp
- cf594d，1，2500，T，F，询问按右端点排序 维护一个树状数组表示区间中出现的素数的乘积 然后按照欧拉函数的公式算答案就行了 -- zyp

---

**2021-02-01**

- cf1065f，1，2500，T，F， 先算可以任意回到根节点的叶子节点的数目 然后再dp算不能回到根节点的路径的答案即可 -- zyp
- cf1017f，1，2500，T，F，此题主要问题是空间太小 所以需要用埃式筛并且埃式筛数组只开x%6=+-1的情况 其他的就正常推公式即可 -- zyp
- cf1461f，2,2700，T，F，ai乘积大于2n时全乘号链接，ai乘积小于2n时dp转移即可 -- lsz
- cf1452g，2，2700，T，F，将原问题转化为每一个点至少可以进行的回合数，即多少个回合内不会有任何一个chip到这个点，然后再将相邻的点向外扩展最终覆盖整棵树即可 -- lsz
- cf455d，2，2700，T，F，分块，模拟移动时需要用deque而不是list来减少时间 -- zyp
- cf1270g，2，2700，T，F，i->i-a[i]连边 然后找一个环即可 -- zyp
- cf1442d，2，2800，T，F，dp决策单调性分治 -- lsz
- cf1422e，2，2700，T，F，分类讨论dp一下 -- lsz
- cf1422f，2，2800，T，F，区间lcm，值域2e5，根据值域的开根，小于开根的暴力线段树，大于开根的主席树 -- lsz
- cf351d，2，2700，T，F，莫队 一个map记录间隔 一个deque记录出现的位置 -- zyp
- cf1461f，2，2700，T，F，先分类讨论 主要处理+*的情况 按照0分割数组 每个子数组里进行dp即可 -- zyp
- AGC006C，2，800，T，T，“每次跳跃的位置的期望由位置的期望可表示为：两边之和减去中间，在差分序列上就是交换2个相邻元素，K次就快速幂算排列” -- wys
- AGC008C，1，600，T，T，“有用的只有3个，讨论奇偶，是否为0，注意细节” -- wys
- AGC008D，2，800，T，F，“左右分开贪心，每种数字按照确定位置为优先级” -- wys
- AGC009B，2，800，T，F，“dfs(u)表示以u胜利的最少场次，转移时将最深的深度贪心的放在靠上的位置即可” -- wys
- cf906d，2，2700，T，F，扩展欧拉定理 因为要分是否大于欧拉函数 所以要魔改一下快速幂 返回的范围改为 0~2*p-1 -- zyp
- AGC010B，1，500，T，T，“考虑相邻2个人数的差值即可，细节调了一年” -- wys
- cf713d，2，2700，T，F，dp[i][j]表示以ij为右下角最大正方形边长 在dp上建立二维st表 询问的时候二分答案即可
- AGC009C，3，1100，T，T，“dpx[i][j]表示"前i个数，划分为2个集合X,Y，第i个属于集合X，最后一个加入集合Y中的数字编号为j"的方案数。dpy相似，考虑dp的转移过程，只保留dp的第二维，用线段树更新dp数组”
- AGC010C，1，700，T，F，“仔细读题。把点上权转化到边上”