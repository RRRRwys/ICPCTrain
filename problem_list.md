**2021-01-01**

- CF1466G，2，2500，T，T，"定义f(n,w)表示sn中w出现的次数，g(n,w)为在sn中经过ti字符的w的数目，f(n,w)=2*f(n-1,w)+g(n,w)=2^{n-k}*f(k,w)+\sum_{j=k+1}^n 2^{n-j}*g(j,w)，选取 k 使得|sk| > w；对于这种情况，ti == tj 时，有g(i,w)==g(j,w)；第一部分kmp统计f，第二部分对每一种字母kmp统计g的贡献，注意边界" -- wys
- AGC051A，2，500，T，T，"构造可以发现最外层形式固定，接下的一层的是由两种长度的边d,d-1交替构成的12边形，令方案数为f(d,d-1)。可以发现只有两种构造方式，有f(n,m)=f(n-1,m)+f(n,m-1), 然后根据组合数递推式C(n,m) = C(n-1,m) + C(n-1,m-1)，可发现f(n,m) = C(n+m,m) = C(n+m-1,m) + C(n+m-1,m-1) = f(n-1,m) + f(n,m-1)，于是发现f(n,m)与C(n+m,m)差了1/2，这个组合数的形式需要记忆" -- wys
- cf342E，1，2400，T，T，“对询问分块，块内的修改暴力处理，每个块结束时将当前块修改作用到树上” -- zyp
- cf375D，1，2400，T，T，“dfs序+莫队” -- zyp
- cf449D，1，2400，T，T，“通过dp得到某个数所有超集的数目 然后代公式即可” -- zyp
- AGC001B，1， 500，T，T，"第一次反射构成一个大平行四边形，之后的所有操作都可以递归的化成：平行四边形一个钝角发射光线" -- wys
- AGC001C，1，600，T，T，“枚举答案中树直径的中边，讨论即可” -- zyp

--- 

**2021-01-25**

- cf865d，1，2400，T，T，贪心 把买卖的式子转换一下就可以用优先队列贪了 -- zyp
- cf446c，1，2400，in queue，F，搞出模意义下的斐波那契数列的通项公式 然后线段树加加减减打打标记 --zyp
- cf1187d，1，2400，T，F，将sort转换为swap 然后只要验证下一个可能位置前所有值都大于当前值即可 对每个位置操作完就更新一下 -- zyp
- AGC001D, 3, 1000, T, T, “将回文串中相等字符想象成有边相连，目标就是使得整个图联通，发现回文串的奇偶性会影响结果，分析发现奇数长度的串，只能作为开头和结尾，偶数长度可以随便放，因此奇数长度大于2一定无解；将奇+偶，偶+奇，偶+偶，奇+奇，分别构造出可行的方案，把他们串起来即可” -- wys
- cf145e，1，2400，T，F，线段树同时处理翻转前和翻转后的结果即可 -- zyp
- AGC002C，1，500，T，F，“考虑最后一步从哪里切开，两边的可以朝这个位置按顺序切” -- wys
- cf1358e，1，2400，T，F，先证（猜）一下答案肯定大于n/2 然后观察k相同时相邻两个区间的和的差 发现是一个前缀和 再观察k+1时候的结果 发现就差一个x 然后枚举一下k就行了 -- zyp
- AGC002D，3，1000，T，T，“可持久化并查集按编号从小到大加边，二分答案，内存开到上限” -- wys
- cf484d，1，2400，T，F，先按照递增递减分段 然后再枚举各种情况dp即可 -- zyp
- cf1114F，1cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可，2400，T，F，一棵线段树处理区间乘法 另一棵线段树处理一下区间出现的素数 然后套欧拉函数公式即可 -- zyp
- AGC003C，1，600，T，F，“离散化之后的编号与位置编号，奇+偶数目与偶+奇数目取max” -- wys
- cf1469f，1，2600， T，F，贪心，选择剩余最长链的中心挂在树上距离跟最近的白色点上即可。 -- lsz
- cf1467e，1,2500，T，F，由每个点的修改次数最多为size+1，故直接dfs的时候搞一搞就好 -- lsz
- AGC003D，3，1100，T，T，“素因子分解后，每个素因子的指数模3得到序列a，考虑对于每个处理后非1的数，必定有唯一一个与他对应的数，因此将可能的乘积为立方数的对，一定是一一对应的；因此，建图之后1是一个单点，其余的每一个联通块大小都不超过2；讨论每种情况，容易求出最大独立集。数据范围为1e10，时限很紧，分解质因数采用杜教的，小的预处理，大的rho” -- wys
- cf626e，1，2400，T，F，枚举中位数 三分答案长度 取最大值即可 -- zyp
- cf1036f，1，2400，T，F，枚举gcd 用莫比乌斯函数容斥即可 开根的时候要注意精度问题 -- zyp
- AGC004C，1，700，T，T，“构造题，搞左右两个交错互补的叉子，分别与交的的网格求并即可” -- wys
- AGC004D，2，800，T，T，“容易知道1一定指向自己，因此题目就是求切最少的边使得，每棵树深度不超过K-1，根所在树不超过K；因此按深度倒序的考虑，每个未删除的点选择它的K-1级祖先与K级祖先之间的边” -- wys
- cf986c，1，2500，T，F，引入辅助结点 将条件转换为结点连向辅助结点的边 然后跑dfs即可 要注意的是存图会导致内存不够 所以边要现场算 -- zyp 
- cf1305f，1，2500，T，F，考虑到操作总数不超过n 至少有n/2的数字操作数不超过1 所以随机这个数 把它、+1、-1的数的因子搞出来算一遍 然后取最小值 -- zyp
- AGC005C，1，700，T，F，“对于一棵树，最大的2个值一定相等，并且是直径的长度，这样就可以把整个链推出来，其余的点按值从小到大加入树中，如果书中存在一个点的值恰好比当前值小1，则可以把这个点连上去” -- wys
- AGC005D，2，900，T，T，“容斥，枚举匹配中包含的非法匹配个数，问题转化为求解非法的二分图上的匹配数位恰好为k的方案数，可以发现这个二分图由一些独立的链构成，因此可以求解每一条链的方案，之后再卷积合并答案；对于一条链的二分图匹配方案数，转化为2染色，相邻两边不能同色的方案数，n^2 dp 即可” -- wys
- cf551e，1，2500，T，F，分块 对于修改 块内直接加 整个块打标记 对于查询 块内排序 用二分查询是否存在 找出最大最小index然后相减即可 -- zyp
